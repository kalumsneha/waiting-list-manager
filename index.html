<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>DBN Games Manager</title>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
body{font-family:Arial,sans-serif;background:#f4f6f8;margin:0;padding:20px}
h2{text-align:center}

/* ---------- NAV ---------- */
.nav{
  display:flex;
  justify-content:center;
  gap:20px;
  margin-bottom:20px;
}
.nav button{
  background:#263238;
}
.nav button.active{
  background:#1976d2;
}

/* ---------- CONTROLS ---------- */
.controls,.limit-controls{
  max-width:900px;
  margin:15px auto;
  display:flex;
  gap:10px
}

input,select{
  flex:1;padding:10px;border-radius:6px;border:1px solid #ccc
}

button{
  padding:10px 15px;
  border-radius:6px;
  border:none;
  cursor:pointer;
  background:#1976d2;
  color:white;
  font-weight:bold
}

button:hover{background:#125aa0}

.container{
  display:flex;
  gap:20px;
  max-width:900px;
  margin:auto
}

.panel{
  flex:1;
  background:white;
  padding:15px;
  border-radius:10px;
  box-shadow:0 2px 6px rgba(0,0,0,.1)
}

.panel h3{text-align:center;margin-top:0}

.list{
  min-height:300px;
  border:2px dashed #ccc;
  border-radius:8px;
  padding:10px
}

.item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  background:#e3f2fd;
  margin:10px 0;
  padding:14px 16px;
  border-radius:8px;
  font-size:20px;
  font-weight:600;
}

.item.incourt{background:#c8e6c9}

.icon-btn{
  width:64px;height:64px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  font-size:32px;cursor:pointer;
  box-shadow:0 3px 8px rgba(0,0,0,.25);
}

.btn-move{background:#4caf50;color:white}
.btn-back{background:#f44336;color:white}
.btn-stay{background:#ff9800;color:white}

.icon-disabled{
  background:#bdbdbd !important;
  cursor:not-allowed;
  opacity:.5;
  pointer-events:none;
}

.actions{display:flex;gap:14px}

/* ---------- TEAM PAGE ---------- */
#teamPage{display:none}

.team-controls{
  max-width:900px;
  margin:auto;
  display:flex;
  gap:10px;
  margin-bottom:15px;
}

.team-box{
  background:white;
  padding:15px;
  border-radius:10px;
  margin:10px auto;
  max-width:900px;
  box-shadow:0 2px 6px rgba(0,0,0,.1);
}

.team{
  border:1px solid #ccc;
  border-radius:8px;
  padding:10px;
  margin:10px 0;
}

.match{
  background:#e8f5e9;
  padding:10px;
  margin:6px 0;
  border-radius:6px;
  font-weight:bold;
}

/* ---------- Player Context Menu ---------- */

.menu-wrapper{
  position:relative;
  display:flex;
  align-items:center;
  gap:8px;
}

.menu-btn{
  width:40px;
  height:40px;
  border-radius:50%;
  background:#455a64;
  color:white;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:22px;
}

.menu-panel{
  position:absolute;
  top:45px;
  right:0;
  background:white;
  border-radius:10px;
  box-shadow:0 6px 16px rgba(0,0,0,.25);
  display:none;
  flex-direction:column;
  min-width:180px;
  z-index:100;
  overflow:hidden;
}

.menu-panel.show{
  display:flex;
}

.menu-item{
  padding:12px 14px;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  display:flex;
  align-items:center;
  gap:10px;
  transition:background .15s;
}

.menu-item:hover{
  background:#f1f1f1;
}

.menu-danger{
  color:#c62828;
}

.menu-edit{
  color:#1565c0;
}

.left-box{
  flex:1;
  display:flex;
  align-items:center;
  font-size:20px;
  font-weight:600;
}

.right-box{
  display:flex;
  align-items:center;
  gap:12px;
  justify-content:flex-end;
}


</style>
</head>

<body>

<h2>üè∏ DBN Games Manager</h2>

<div class="nav">
  <button id="btnQueue" class="active" onclick="showPage('queue')">Queue Manager</button>
  <button id="btnTeam" onclick="showPage('team')">Team Generator</button>
  <button id="btnPlayers" onclick="showPage('players')">Player Manager</button>
</div>

<!-- ================= QUEUE PAGE ================= -->
<div id="queuePage">

<div class="limit-controls">
<input type="number" id="maxInCourt" placeholder="Max in-court players" min="1" />
<button onclick="setLimit()">Set Limit</button>
</div>

<div class="controls">
<select id="playerSelect" multiple></select>
<input type="text" id="nameInput" placeholder="Enter new names (comma separated)" />
<button onclick="addSelectedOrNewPlayers()">Add Players</button>
<button onclick="clearCourt()">Clear Court</button>
<button onclick="undoLastAction()">‚Ü© Undo</button>
</div>

<div class="container">
<div class="panel">
<h3>‚è≥ Waiting List</h3>
<div id="waitingList" class="list"></div>
</div>

<div class="panel">
<h3>üèüÔ∏è In-Court List</h3>
<div id="inCourtList" class="list"></div>
</div>
</div>

</div>

<!-- ================= TEAM PAGE ================= -->
<div id="teamPage">

<div class="team-controls">
<select id="teamSize">
  <option value="2">Team Size 2</option>
  <option value="3">Team Size 3</option>
  <option value="4">Team Size 4</option>
</select>

<button onclick="generateTeams()">Generate Teams</button>
<button onclick="reshuffleTeams()">üîÅ Reshuffle</button>
<button onclick="generateMatches()">Generate Matches</button>
</div>

<div id="teamsContainer" class="team-box"></div>
<div id="matchesContainer" class="team-box"></div>

</div>

<!-- ================= PLAYER MANAGER PAGE ================= -->
<div id="playersPage" style="display:none">

<div class="team-controls">
  <input id="newPlayerName" placeholder="Name"/>
  <input id="newPlayerSkill" type="number" min="1" max="5" placeholder="Skill (1‚Äì5)"/>
  <select id="newPlayerGender">
    <option value="M">Male</option>
    <option value="F">Female</option>
    <option value="O">Other</option>
  </select>
  <button onclick="addNewPlayer()">Add Player</button>
</div>

<div id="playersContainer" class="team-box"></div>

</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="firebase-config.js"></script>

<script>
firebase.initializeApp(window.FIREBASE_CONFIG);
const db = firebase.database();
const stateRef = db.ref("fifoState");
const actionsRef = db.ref("fifoActions");
</script>

<script>
let state={
  waiting:[],
  incourt:[],
  maxInCourt:null,
  stats:{} // name -> {games, skill, gender, history}
};

let initialized=false;
let actionHistory = [];

/* ---------- NAV ---------- */
function showPage(p){
  queuePage.style.display = p==='queue'?'block':'none';
  teamPage.style.display = p==='team'?'block':'none';
  playersPage.style.display = p==='players'?'block':'none';

  btnQueue.classList.toggle('active',p==='queue');
  btnTeam.classList.toggle('active',p==='team');
  btnPlayers.classList.toggle('active',p==='players');
}


function normalizeState(s){
  return {
    waiting: Array.isArray(s.waiting) ? s.waiting : [],
    incourt: Array.isArray(s.incourt) ? s.incourt : [],
    maxInCourt: (s.maxInCourt === undefined ? null : s.maxInCourt),
    stats: (typeof s.stats === 'object' && s.stats !== null ? s.stats : {})
  };
}

/* ---------- INIT ---------- */
stateRef.once("value").then(snap=>{
  if(snap.exists()) state = normalizeState(snap.val());
  else stateRef.set(state);
  initialized=true;
  updatePlayerSelect();
  render();
});

stateRef.on("value",snap=>{
  if(!initialized) return;
  if(snap.exists()){
    state = normalizeState(snap.val());
    updatePlayerSelect();
    render();
    renderPlayersPage();
  }
});

function save(){ stateRef.set(state); }


/* ---------- QUEUE LOGIC (UNCHANGED CORE) ---------- */

/*function setLimit(){
  const v=parseInt(maxInCourt.value);
  if(v>0){ state.maxInCourt=v; save(); }
}*/

function setLimit(){
  const v = parseInt(maxInCourt.value);
  if(!(v>0)) return;

  stateRef.transaction(state=>{
    if(!state) return state;
    state.maxInCourt = v;
    return state;
  });
}


function updatePlayerSelect(){
  playerSelect.innerHTML='';
  Object.keys(state.stats).forEach(n=>{
    const o=document.createElement('option');
    o.value=n;o.innerText=n;
    playerSelect.appendChild(o);
  });
}

/*function addSelectedOrNewPlayers(){
  if(!Array.isArray(state.waiting)) state.waiting=[];
  if(!Array.isArray(state.incourt)) state.incourt=[];
  if(!state.stats) state.stats={};

  const selected=[...playerSelect.selectedOptions].map(o=>o.value);
  const raw=nameInput.value.split(',').map(n=>n.trim()).filter(Boolean);
  const all=[...new Set([...selected,...raw])];

  all.forEach(n=>{
    if(!state.stats[n]){
      state.stats[n]={games:0,skill:3,gender:"M",history:{with:{},against:{}}};
    }

    const inWaiting = state.waiting.includes(n);
    const inCourt = state.incourt.find(p=>p.name===n);

    if(!inWaiting && !inCourt){
      state.waiting.push(n);
    }
  });

  nameInput.value='';
  save();
}*/

function addSelectedOrNewPlayers(){
  if(!Array.isArray(state.waiting)) state.waiting=[];
  if(!Array.isArray(state.incourt)) state.incourt=[];
  if(!state.stats) state.stats={};
  
  const selected=[...playerSelect.selectedOptions].map(o=>o.value);
  const raw=nameInput.value.split(',').map(n=>n.trim()).filter(Boolean);
  const all=[...new Set([...selected,...raw])];

  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    all.forEach(n=>{
      if(!state.stats[n]){
        state.stats[n]={games:0,skill:3,gender:"M",history:{with:{},against:{}}};
      }

      const inWaiting = state.waiting.includes(n);
      const inCourt = state.incourt.find(p=>p.name===n);

      if(!inWaiting && !inCourt){
        state.waiting.push(n);
      }
    });

    return state;
  });

  nameInput.value='';
}


/*function clearCourt(){
  state.waiting=[];
  state.incourt=[];
  Object.values(state.stats).forEach(p=>p.games=0);
  save();
}*/

function clearCourt(){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    state.waiting = [];
    state.incourt = [];

    Object.values(state.stats).forEach(p=>{
      p.games = 0;
    });

    return state;
  });
}


function render(){
  waitingList.innerHTML='';
  inCourtList.innerHTML='';

  const prioritized=getPrioritizedWaitingList();
  const slots = state.maxInCourt? state.maxInCourt-state.incourt.length : 999;

  prioritized.forEach((n,i)=>{
    const d=document.createElement('div');d.className='item';

    const label=document.createElement('span');
    label.textContent = `${n} (games:${state.stats[n].games})`;
    
    const b=document.createElement('div');
    b.className='icon-btn btn-move';
    if(i>=slots) b.classList.add('icon-disabled');
    b.innerHTML='<span class="material-icons">arrow_forward</span>';
    b.onclick=()=>moveToInCourtByName(n);

    /* ===== MENU ===== */
    const menuWrap=document.createElement('div');
    menuWrap.className='menu-wrapper';
  
    const menuBtn=document.createElement('div');
    menuBtn.className='menu-btn';
    menuBtn.innerHTML='‚ãÆ';
  
    const menuPanel=document.createElement('div');
    menuPanel.className='menu-panel';


    /* menu items */

    const up=document.createElement('div');
    up.className='menu-item';
    up.innerHTML='‚¨Ü Move Up';
    up.onclick=()=>{ moveUpWaiting(i); closeMenus(); };
  
    const down=document.createElement('div');
    down.className='menu-item';
    down.innerHTML='‚¨á Move Down';
    down.onclick=()=>{ moveDownWaiting(i); closeMenus(); };
  
    const edit=document.createElement('div');
    edit.className='menu-item menu-edit';
    edit.innerHTML='‚úè Edit Games';
    edit.onclick=()=>{ editGameCount(n); closeMenus(); };
  
    const remove=document.createElement('div');
    remove.className='menu-item menu-danger';
    remove.innerHTML='‚úñ Remove';
    remove.onclick=()=>{ removeFromSession(n); closeMenus(); };
  
    menuPanel.appendChild(up);
    menuPanel.appendChild(down);
    menuPanel.appendChild(edit);
    menuPanel.appendChild(remove);
  
    menuBtn.onclick=(e)=>{
      e.stopPropagation();
    
      const isOpen = menuPanel.classList.contains('show');
    
      // close all first
      closeMenus();
    
      // toggle only if it was not already open
      if(!isOpen){
        menuPanel.classList.add('show');
      }
    };

  
    menuWrap.appendChild(menuBtn);
    menuWrap.appendChild(menuPanel);
    
    const leftBox = document.createElement('div');
    leftBox.className = 'left-box';
    leftBox.appendChild(label);
    
    const rightBox = document.createElement('div');
    rightBox.className = 'right-box';
    rightBox.appendChild(b);
    rightBox.appendChild(menuWrap);
    
    d.appendChild(leftBox);
    d.appendChild(rightBox);

    
    waitingList.appendChild(d);
  });

  state.incourt.forEach((p,i)=>{
    const d=document.createElement('div'); 
    d.className='item incourt';
  
    const a=document.createElement('div'); 
    a.className='actions';
  
    /* ---- STAY BUTTON ---- */
    const stay=document.createElement('div');
    stay.className='icon-btn btn-stay';
    stay.innerHTML='<span class="material-icons">refresh</span>';
  
    if(p.extraUsed) stay.classList.add('icon-disabled');
  
    stay.onclick=()=>stayOneMore(p.name);
  
    /* ---- BACK BUTTON ---- */
    const back=document.createElement('div');
    back.className='icon-btn btn-back';
    back.innerHTML='<span class="material-icons">arrow_back</span>';
    back.onclick=()=>moveToWaiting(p.name);
  
    a.appendChild(stay);
    a.appendChild(back);
  
    d.innerHTML=`<span>${p.name}</span>`;
    d.appendChild(a);
    inCourtList.appendChild(d);
  });

}

function getPrioritizedWaitingList(){
  return state.waiting
    .map((n,i)=>({n,g:state.stats[n].games,i}))
    .sort((a,b)=>a.g-b.g||a.i-b.i)
    .map(x=>x.n);
}

/*function moveToInCourtByName(name){
  if(state.maxInCourt && state.incourt.length>=state.maxInCourt) return;
  const i=state.waiting.indexOf(name);
  if(i===-1) return;

  actionHistory.push({
    type:"MOVE_TO_COURT",
    prevWaiting:[...state.waiting],
    prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
    prevStats:JSON.parse(JSON.stringify(state.stats))
  });

  state.waiting.splice(i,1);
  state.stats[name].games++;
  state.incourt.push({name, extraUsed:false});
  save();
}*/

function moveToInCourtByName(name){
  stateRef.transaction(state=>{
    if(!state) return state;

    state = normalizeState(state);

    if(state.maxInCourt && state.incourt.length >= state.maxInCourt) return;

    const i = state.waiting.indexOf(name);
    if(i === -1) return;

    actionHistory.push({
      type:"MOVE_TO_COURT",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });

    state.waiting.splice(i,1);

    if(!state.stats[name]) return;
    state.stats[name].games = (state.stats[name].games || 0) + 1;

    state.incourt.push({name, extraUsed:false});

    return state;
  }, ()=>{
    // log AFTER success
    logAction({type:"MOVE_TO_COURT", name});
  });
}


/*function moveToWaiting(i){
  actionHistory.push({
    type:"MOVE_TO_WAITING",
    prevWaiting:[...state.waiting],
    prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
    prevStats:JSON.parse(JSON.stringify(state.stats))
  });

  const p=state.incourt.splice(i,1)[0];
  state.waiting.push(p.name);
  save();
}*/

/*function moveToWaiting(i){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    if(!state.incourt[i]) return;

    actionHistory.push({
      type:"MOVE_TO_WAITING",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });
    
    const p = state.incourt.splice(i,1)[0];
    state.waiting.push(p.name);

    return state;
  });
}*/

function moveToWaiting(name){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    const pIndex = state.incourt.findIndex(p=>p.name===name);
    if(pIndex===-1) return;

    actionHistory.push({
      type:"MOVE_TO_WAITING",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });

    const p = state.incourt.splice(pIndex,1)[0];
    state.waiting.push(p.name);

    return state;
  }, ()=>{
    // log AFTER success
    logAction({type:"MOVE_TO_WAITING", name});
  });
}



/*function stayOneMore(i){
  const p = state.incourt[i];
  if(p.extraUsed) return;

  actionHistory.push({
    type:"STAY",
    prevWaiting:[...state.waiting],
    prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
    prevStats:JSON.parse(JSON.stringify(state.stats))
  });

  p.extraUsed = true;
  state.stats[p.name].games++;
  save();
}*/

/*function stayOneMore(i){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    const p = state.incourt[i];
    if(!p || p.extraUsed) return;

    actionHistory.push({
      type:"STAY",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });
    
    p.extraUsed = true;
    if(state.stats[p.name]){
      state.stats[p.name].games = (state.stats[p.name].games || 0) + 1;
    }

    return state;
  });
}*/

function stayOneMore(name){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    const p = state.incourt.find(p=>p.name===name);
    if(!p || p.extraUsed) return;

    actionHistory.push({
      type:"STAY",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });
    
    p.extraUsed = true;
    if(state.stats[p.name]){
      state.stats[p.name].games = (state.stats[p.name].games || 0) + 1;
    }

    return state;
  }, ()=>{
    // log AFTER success
    logAction({type:"STAY", name});
  });
}


/* ================= TEAM GENERATOR ================= */

let currentTeams=[];

function getPlayersForTeams(){
  const activeNames = new Set([
    ...state.waiting,
    ...state.incourt.map(p=>p.name)
  ]);

  return [...activeNames].map(n=>({
    name:n,
    skill: state.stats[n]?.skill || 3,
    gender: state.stats[n]?.gender || "M"
  }));
}


function generateTeams(){
  const size=parseInt(teamSize.value);
  const players=getPlayersForTeams();
  const numTeams=Math.floor(players.length/size);
  if(numTeams<1) return;

  players.sort((a,b)=>b.skill-a.skill);

  let teams=[...Array(numTeams)].map(()=>[]);
  let dir=1,idx=0;

  players.forEach(p=>{
    teams[idx].push(p);
    if(dir===1){
      if(idx===numTeams-1) dir=-1; else idx++;
    }else{
      if(idx===0) dir=1; else idx--;
    }
  });

  spreadFemales(teams);
  currentTeams=teams;
  renderTeams();
}

function spreadFemales(teams){
  const femalePositions = [];

  teams.forEach((team, ti)=>{
    team.forEach((p, pi)=>{
      if(p.gender==="F"){
        femalePositions.push({ti,pi,p});
      }
    });
  });

  if(femalePositions.length === 0) return;

  const teamsWithFemale = new Set(femalePositions.map(f=>f.ti));

  for(let i=0;i<femalePositions.length;i++){
    const f = femalePositions[i];

    const duplicates = femalePositions.filter(x=>x.ti===f.ti).length;
    if(duplicates > 1){
      const targetTeamIndex = teams.findIndex((t,idx)=>
        !teamsWithFemale.has(idx)
      );

      if(targetTeamIndex !== -1){
        const swapIndex = teams[targetTeamIndex].findIndex(p=>p.gender!=="F");
        if(swapIndex !== -1){
          const temp = teams[targetTeamIndex][swapIndex];
          teams[targetTeamIndex][swapIndex] = f.p;
          teams[f.ti][f.pi] = temp;

          teamsWithFemale.add(targetTeamIndex);
        }
      }
    }
  }
}

function reshuffleTeams(){
  const size = parseInt(teamSize.value);
  let players = getPlayersForTeams();

  const numTeams = Math.floor(players.length / size);
  if(numTeams < 1) return;

  // true shuffle
  for(let i = players.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [players[i], players[j]] = [players[j], players[i]];
  }

  // generate many candidates, pick best balance
  let bestTeams = null;
  let bestScore = Infinity;

  for(let r = 0; r < 80; r++){   // 80 random attempts
    let tempPlayers = [...players];

    // reshuffle each round
    for(let i = tempPlayers.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [tempPlayers[i], tempPlayers[j]] = [tempPlayers[j], tempPlayers[i]];
    }

    let teams = Array.from({length:numTeams},()=>[]);

    tempPlayers.forEach(p=>{
      // place into team with lowest skill sum
      teams.sort((a,b)=>
        a.reduce((s,x)=>s+x.skill,0) - b.reduce((s,x)=>s+x.skill,0)
      );
      teams[0].push(p);
    });

    spreadFemales(teams);

    // balance score
    const sums = teams.map(t=>t.reduce((a,b)=>a+b.skill,0));
    const avg = sums.reduce((a,b)=>a+b,0)/sums.length;
    const score = sums.reduce((s,v)=>s+Math.abs(v-avg),0);

    if(score < bestScore){
      bestScore = score;
      bestTeams = teams;
    }
  }

  currentTeams = bestTeams;
  renderTeams();
}


function renderTeams(){
  teamsContainer.innerHTML='';
  currentTeams.forEach((t,i)=>{
    const sum=t.reduce((a,b)=>a+b.skill,0);
    const d=document.createElement('div');
    d.className='team';
    d.innerHTML=`<b>Team ${i+1} (Skill Sum: ${sum})</b><br>`+
      t.map(p=>`${p.name} (${p.skill}${p.gender==="F"?"F":""})`).join('<br>');
    teamsContainer.appendChild(d);
  });
}

function generateMatches(){
  matchesContainer.innerHTML='';
  for(let i=0;i<currentTeams.length;i+=2){
    if(currentTeams[i+1]){
      const d=document.createElement('div');
      d.className='match';
      d.innerText=`Team ${i+1} vs Team ${i+2}`;
      matchesContainer.appendChild(d);
    }
  }
}

  /* ================= Player Manager ================= */

  function renderPlayersPage(){
  playersContainer.innerHTML='';

  Object.keys(state.stats).forEach(name=>{
    const p=state.stats[name];

    const row=document.createElement('div');
    row.className='team';

    row.innerHTML=`
      <b>${name}</b><br>
      Skill: <input type="number" min="1" max="5" value="${p.skill}" 
             onchange="updatePlayer('${name}', 'skill', this.value)">
      Gender: 
      <select onchange="updatePlayer('${name}', 'gender', this.value)">
        <option value="M" ${p.gender==="M"?"selected":""}>M</option>
        <option value="F" ${p.gender==="F"?"selected":""}>F</option>
        <option value="O" ${p.gender==="O"?"selected":""}>O</option>
      </select>
    `;

    playersContainer.appendChild(row);
  });
}

function updatePlayer(name,field,value){
  if(!state.stats[name]) return;
  if(field==='skill') value=parseInt(value);
  state.stats[name][field]=value;
  save();
}

function addNewPlayer(){
  const name=newPlayerName.value.trim();
  const skill=parseInt(newPlayerSkill.value)||3;
  const gender=newPlayerGender.value;

  if(!name) return;

  if(!state.stats[name]){
    state.stats[name]={games:0,skill,gender,history:{with:{},against:{}}};
  }

  newPlayerName.value='';
  newPlayerSkill.value='';
  save();
}

  /* ================= Remove Player from Session ================= */

/*function removeFromSession(name){
  actionHistory.push({
    type:"REMOVE_PLAYER",
    prevWaiting:[...state.waiting],
    prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
    prevStats:JSON.parse(JSON.stringify(state.stats))
  });

  state.waiting = state.waiting.filter(n=>n!==name);
  state.incourt = state.incourt.filter(p=>p.name!==name);
  save();
}*/

function removeFromSession(name){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

     actionHistory.push({
      type:"REMOVE_PLAYER",
      prevWaiting:[...state.waiting],
      prevInCourt:JSON.parse(JSON.stringify(state.incourt)),
      prevStats:JSON.parse(JSON.stringify(state.stats))
    });
    
    state.waiting = state.waiting.filter(n=>n!==name);
    state.incourt = state.incourt.filter(p=>p.name!==name);

    return state;
  }, ()=>{
    // log AFTER success
    logAction({type:"REMOVE", name});
  });
}

  
/* ================= Player Context Menu ================= */

function closeMenus(){
  document.querySelectorAll('.menu-panel').forEach(m=>m.classList.remove('show'));
}

document.addEventListener('click',closeMenus);

/* ===== ADMIN ACTIONS ===== */

/*function moveUpWaiting(i){
  if(i<=0) return;
  const arr=state.waiting;
  [arr[i-1],arr[i]]=[arr[i],arr[i-1]];
  save();
}*/

function moveUpWaiting(i){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    if(i<=0 || i>=state.waiting.length) return;

    const arr=state.waiting;
    [arr[i-1],arr[i]]=[arr[i],arr[i-1]];

    return state;
  });
}


/*function moveDownWaiting(i){
  const arr=state.waiting;
  if(i>=arr.length-1) return;
  [arr[i],arr[i+1]]=[arr[i+1],arr[i]];
  save();
}*/

function moveDownWaiting(i){
  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    if(i<0 || i>=state.waiting.length-1) return;

    const arr=state.waiting;

    [arr[i],arr[i+1]]=[arr[i+1],arr[i]];

    return state;
  });
}


/*function editGameCount(name){
  const current = state.stats[name].games || 0;
  const v = prompt(`Edit game count for ${name}:`, current);
  if(v===null) return;
  const num = parseInt(v);
  if(isNaN(num) || num<0) return alert("Invalid number");
  state.stats[name].games = num;
  save();
}*/

function editGameCount(name){
  const current = state.stats[name]?.games || 0;
  const v = prompt(`Edit game count for ${name}:`, current);
  if(v===null) return;
  const num = parseInt(v);
  if(isNaN(num) || num<0) return alert("Invalid number");

  stateRef.transaction(state=>{
    if(!state) return state;
    state = normalizeState(state);

    if(state.stats[name]){
      state.stats[name].games = num;
    }

    return state;
  }, ()=>{
    // log AFTER success
    logAction({type:"EDIT_GAMES", name});
  });
}

/* ================= Global Distributed Undo Option================= */

function logAction(action){
  actionsRef.push({
    ...action,
    timestamp: Date.now()
  });
}

/*function undoLastAction(){
  if(actionHistory.length === 0) return;
  const last = actionHistory.pop();
  state.waiting = last.prevWaiting;
  state.incourt = last.prevInCourt;
  state.stats = last.prevStats;
  save();
}*/
  
function undoLastAction(){
  actionsRef.orderByChild("timestamp").limitToLast(1).once("value", snap=>{
    if(!snap.exists()) return;

    const lastKey = Object.keys(snap.val())[0];

    // remove last action
    actionsRef.child(lastKey).remove().then(()=>{
      rebuildStateFromActions();
    });
  });
}

function rebuildStateFromActions(){
  actionsRef.once("value").then(snap=>{
    let actions = [];
    if(snap.exists()){
      actions = Object.values(snap.val()).sort((a,b)=>a.timestamp-b.timestamp);
    }

    const newState = {
      waiting:[],
      incourt:[],
      maxInCourt: state.maxInCourt || null,
      stats:{}
    };

    actions.forEach(a=>{
      if(!newState.stats[a.name]){
        newState.stats[a.name]={games:0,skill:3,gender:"M",history:{}};
      }

      switch(a.type){
        case "MOVE_TO_COURT":
          newState.waiting = newState.waiting.filter(n=>n!==a.name);
          newState.incourt.push({name:a.name, extraUsed:false});
          newState.stats[a.name].games++;
          break;

        case "MOVE_TO_WAITING":
          newState.incourt = newState.incourt.filter(p=>p.name!==a.name);
          if(!newState.waiting.includes(a.name))
            newState.waiting.push(a.name);
          break;

        case "STAY":
          const p = newState.incourt.find(p=>p.name===a.name);
          if(p){
            p.extraUsed=true;
            newState.stats[a.name].games++;
          }
          break;

        case "EDIT_GAMES":
          newState.stats[a.name].games = a.value;
          break;

        case "REMOVE":
          newState.waiting = newState.waiting.filter(n=>n!==a.name);
          newState.incourt = newState.incourt.filter(p=>p.name!==a.name);
          break;
      }
    });

    stateRef.set(newState);
  });
}



</script>

</body>
</html>
